<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orange Catcher</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        :root {
            --orange-primary: #FF8C00; /* DarkOrange */
            --orange-light: #FFA500; /* Orange */
            --orange-dark: #CC7700;
            --yellow-accent: #FFD700; /* Gold */
            --brown-earth: #8B4513; /* SaddleBrown */
            --text-color: #333;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--yellow-accent);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px; /* Reduced padding for more space */
            box-sizing: border-box;
            color: var(--text-color);
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 95vmin; /* Increased width */
            height: 85vmin; /* Increased height */
            max-width: 800px; /* Increased max-width */
            max-height: 700px; /* Increased max-height */
            background-color: var(--orange-light);
            border: 10px solid var(--orange-dark);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            touch-action: none; /* Disables default touch actions for better game control */
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        #player {
            position: absolute;
            bottom: 20px;
            width: 80px;
            height: 20px;
            background-color: var(--brown-earth);
            border-radius: 5px;
            left: calc(50% - 40px); /* Center the player initially */
        }

        .orange {
            position: absolute;
            top: -50px; /* Start off-screen */
            width: 40px;
            height: 40px;
            background-color: var(--orange-primary);
            border-radius: 50%;
            border: 2px solid var(--orange-dark);
            box-shadow: inset -5px -5px 10px rgba(0, 0, 0, 0.2), 
                        inset 5px 5px 10px rgba(255, 255, 255, 0.5);
            animation: fall 3s linear infinite; /* Fall animation */
        }

        @keyframes fall {
            from {
                transform: translateY(0);
            }
            to {
                transform: translateY(100vh);
            }
        }

        .game-over-modal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
            z-index: 20;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 20px;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .game-over-modal h2 {
            font-size: 3em;
            margin: 0;
        }

        .game-over-modal p {
            font-size: 1.5em;
            margin: 10px 0 20px;
        }

        .restart-button {
            padding: 10px 20px;
            font-size: 1.2em;
            background-color: var(--brown-earth);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .restart-button:hover {
            background-color: #6a340f;
        }
        
        /* Responsive styles for smaller screens */
        @media (max-width: 600px) {
            .game-container {
                width: 95vmin;
                height: 95vmin;
            }
            #player {
                width: 60px;
                height: 15px;
            }
            .orange {
                width: 30px;
                height: 30px;
            }
            #score-display {
                font-size: 1.5em;
            }
            .game-over-modal h2 {
                font-size: 2em;
            }
            .game-over-modal p {
                font-size: 1.2em;
            }
            .restart-button {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- Score display -->
        <div id="score-display">Score: 0</div>
        <!-- The player element (the basket) -->
        <div id="player"></div>
        
        <!-- Game Over screen -->
        <div class="game-over-modal" id="gameOverModal">
            <h2>Game Over!</h2>
            <p>Your Score: <span id="finalScore">0</span></p>
            <button class="restart-button" id="restartButton">Play Again</button>
        </div>
    </div>

    <script>
        // Get references to all necessary DOM elements
        const gameContainer = document.querySelector('.game-container');
        const player = document.getElementById('player');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        // Game state variables
        let score = 0;
        let isGameOver = false;
        let playerX = gameContainer.clientWidth / 2 - player.clientWidth / 2;
        let oranges = [];
        let gameLoopInterval;
        let orangeSpawnInterval;

        // Function to update the player's position
        function updatePlayerPosition() {
            player.style.left = `${playerX}px`;
        }

        // Handle keyboard input for player movement
        function handleKeydown(e) {
            if (isGameOver) return;

            const playerSpeed = 10;
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                playerX -= playerSpeed;
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                playerX += playerSpeed;
            }

            // Keep the player within the game container boundaries
            const containerWidth = gameContainer.clientWidth;
            const playerWidth = player.clientWidth;
            if (playerX < 0) {
                playerX = 0;
            } else if (playerX > containerWidth - playerWidth) {
                playerX = containerWidth - playerWidth;
            }
            updatePlayerPosition();
        }

        // Handle touch and mouse input for player movement
        function handlePointerMove(e) {
            if (isGameOver) return;
            // Get the horizontal position relative to the game container
            const containerLeft = gameContainer.getBoundingClientRect().left;
            let clientX = e.clientX;
            // Use e.touches for touch events
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
            }
            
            // Calculate the new player position
            const newPlayerX = clientX - containerLeft - (player.clientWidth / 2);

            // Update player position, clamping it to the container's bounds
            playerX = Math.max(0, Math.min(newPlayerX, gameContainer.clientWidth - player.clientWidth));
            updatePlayerPosition();
        }

        // Function to create and add a new orange to the game
        function createOrange() {
            if (isGameOver) return;
            const orange = document.createElement('div');
            orange.classList.add('orange');
            // Set a random starting horizontal position
            orange.style.left = `${Math.random() * (gameContainer.clientWidth - 40)}px`;
            gameContainer.appendChild(orange);
            oranges.push(orange);
        }

        // The main game loop
        function gameLoop() {
            if (isGameOver) return;

            // Move each orange down
            oranges.forEach(orange => {
                const orangeTop = orange.offsetTop;
                const orangeHeight = orange.offsetHeight;
                const orangeSpeed = 2 + (score * 0.01); // Increase speed with score
                orange.style.top = `${orangeTop + orangeSpeed}px`;

                // Get the player's position and dimensions
                const playerRect = player.getBoundingClientRect();
                const orangeRect = orange.getBoundingClientRect();
                const containerRect = gameContainer.getBoundingClientRect();

                // Check for collisions between the player and the orange
                if (
                    orangeRect.bottom >= playerRect.top &&
                    orangeRect.right >= playerRect.left &&
                    orangeRect.left <= playerRect.right &&
                    orangeRect.bottom <= playerRect.bottom
                ) {
                    // Collision detected, remove the orange and increase score
                    orange.remove();
                    oranges = oranges.filter(o => o !== orange);
                    score++;
                    scoreDisplay.textContent = `Score: ${score}`;
                }

                // Check if the orange has reached the bottom without being caught
                if (orangeRect.bottom >= containerRect.bottom) {
                    // Game over if an orange is missed
                    endGame();
                }
            });
        }

        // Function to end the game
        function endGame() {
            isGameOver = true;
            // Clear the game loop and orange spawning intervals
            clearInterval(gameLoopInterval);
            clearInterval(orangeSpawnInterval);
            // Show the game over modal with the final score
            finalScoreDisplay.textContent = score;
            gameOverModal.style.display = 'flex';
        }

        // Function to start a new game
        function startGame() {
            score = 0;
            isGameOver = false;
            scoreDisplay.textContent = `Score: 0`;
            gameOverModal.style.display = 'none';

            // Remove all existing oranges
            oranges.forEach(orange => orange.remove());
            oranges = [];

            // Reset player position
            playerX = gameContainer.clientWidth / 2 - player.clientWidth / 2;
            updatePlayerPosition();

            // Start the game loop and orange spawning
            gameLoopInterval = setInterval(gameLoop, 16); // ~60fps
            orangeSpawnInterval = setInterval(createOrange, 1000); // Create an orange every second
        }

        // Add event listeners
        document.addEventListener('keydown', handleKeydown);
        gameContainer.addEventListener('pointermove', handlePointerMove);
        restartButton.addEventListener('click', startGame);

        // Make the game responsive on resize
        window.addEventListener('resize', () => {
            const containerWidth = gameContainer.clientWidth;
            const playerWidth = player.clientWidth;
            if (playerX > containerWidth - playerWidth) {
                playerX = containerWidth - playerWidth;
            }
            updatePlayerPosition();
        });

        // Start the game when the window loads
        window.onload = startGame;
    </script>
</body>
</html>

